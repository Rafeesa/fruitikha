const User=require("../../models/userSchema")
const env=require("dotenv").config()
const nodemailer=require("nodemailer")
const bcrypt=require("bcrypt")


const loadHomepage=async(req,res)=>{
    try {
        const user=req.session.user
        if(user)
        {
            const userData=await User.findOne({_id:user._id})
            console.log(userData)
            res.render("home",{user:userData})
        }
        else{
            return res.render('home')
        }
        
    } catch (error) {
        console.log("Home Page Not Found")
        res.status(500).send("server error")
    }

}
const loadSignup=async(req,res)=>{
    try {
        return res.render('signup')
    } catch (error) {
        console.log('Signup page not loading',error)
        res.status(500).send('server error')
        
    }
}

function generateOtp()
{
    const genotp= Math.floor((100000+Math.random()*900000)).toString()
    console.log(genotp)
    return genotp
}

async function sendVerificationEmail(email,otp){
    try {
        const transporter =nodemailer.createTransport({
            service:'gmail',
            port:587,
            secure:false,
            requireTLS:true,
            auth:{
                user:process.env.NODEMAILER_EMAIL,
                pass:process.env.NODEMAILER_PASSWORD
            }
        })

        const info=await transporter.sendMail({
            from:process.env.NODEMAILER_EMAIL,
            to:email,
            subject:"verify your account",
            text:`Your OTP is ${otp}`,
            html:`<b> Your OTP:${otp}</b>`
        })
      
        console.log("Email Sent Status:", info.accepted.length > 0);
        return info.accepted.length > 0; 
    } catch (error) {
        console.error("Error sending email",error)
        return false
    }
}

const signup=async(req,res)=>{
    

try {
    console.log('Request Body:', req.body); 
    const {name,email,phone,password,cPassword}=req.body
    console.log('Checking passwords...');

   if(password!==cPassword){
        return res.render("signup",{message:"password do not match"})
    }
    console.log('Checking if user exists...');
   const findUser=await User.findOne({email})
   console.log("User found:", findUser); 
   
    if(findUser)
    {
        return res.render("signup",{message:"user with this email already exist"})
    }
console.log("hello")
    const otp=generateOtp();
    console.log(otp)
    const emailSent=await sendVerificationEmail(email,otp)
    console.log("OTP:", otp, "Email Sent:", emailSent);  // log OTP and email status
    if(!emailSent){
        return res.json("email sending error")
    }
    req.session.userOtp=otp
    req.session.userData={name,phone,email,password}
   res.render("verify-otp")
    console.log("OTP Sent",otp)
} catch (error) {
    console.error("signup error",error)
      
}
}

const securePassword=async(password)=>{
try {
    const passwordHarsh=await bcrypt.hash(password,10)
    return passwordHarsh   
} catch (error) {
    console.error("Error hashing the password:", error);
}
}



const verifyOtp=async(req,res)=>{
    try {
        const {otp}=req.body
        console.log(otp)
        if(otp===req.session.userOtp){
            const user=req.session.userData
            const passwordHarsh=await securePassword(user.password)
            const saveUserData=new User({
                name:user.name,
                email:user.email,
                phone:user.phone,
                password:passwordHarsh,
            })
            await saveUserData.save()
            req.session.user=saveUserData._id;
            res.redirect('/')
          /*  res.json({success:true,redirectUrl:"/"})*/
        }else{
        res.status(400).json({success:false,message:"Invalid OTP,please Try again"})
        }
    } catch (error) {
       console.error("Error verifying OTP",error) 
       res.status(500).json({success:false,message:"An error occured"})
    }
}


const resendOtp=async(req,res)=>{
    try {
        const {email}=req.session.userData
        if(!email){
         return res.status(400).json({success:false,message:"Email not found in session"})
        }
         const otp=generateOtp()
         req.session.userOtp=otp
         const emailSent=await sendVerificationEmail(email,otp)
         if(emailSent)
         {
            console.log("Resend OTP",otp)
            res.status(200).json({success:true,message:"OTP Resend Successfully"})

         }
         else{
            res.status(500).json({success:false,message:"Failed to resend OTP.Please try again"})
         }
    } catch (error) {
        console.error("Error resending otp",error)
        res.status(500).json({success:false,message:"Internal server erros.Please try again"})
    }
}




const loadLogin=async(req,res)=>
{
    try {
        if(!req.session.user){
            return res.render("login")
        }
        else
        {
            res.redirect("/")
        }
           
    } catch (error) {
 
    }
}


const login=async(req,res)=>
{
    try {
         const {email,password}=req.body
        const findUser=await User.findOne({isAdmin:0,email:email})
        if(!findUser){
            return res.render("login",{message:"user not found"})
        }
        if(findUser.isBlocked){
            return res.render("login",{message:"User is blocked by admin"})
        }

        const passwordMatch=await bcrypt.compare(password,findUser.password)
        if(!passwordMatch){
            return res.render("login",{message:"Incorrect password"})
        }
       req.session.user=findUser._id 
       res.redirect("/")   
    } catch (error) {
        console.error("login error",error)
        res.render("login",{message:"login failed.Please try again later"})
    }
}

module.exports={
    loadHomepage,
    loadSignup,
    signup,
    verifyOtp,
    resendOtp,
    loadLogin,
    login
 
}